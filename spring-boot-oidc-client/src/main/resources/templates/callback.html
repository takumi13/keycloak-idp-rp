<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Authorization Callback</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;padding:20px;max-width:900px}
    h1{font-size:1.2rem}
    table{border-collapse:collapse;width:100%;margin-top:12px}
    th,td{border:1px solid #ddd;padding:8px;text-align:left}
    th{background:#f2f2f2}
    .actions{margin-top:16px;display:flex;gap:8px}
    .btn{padding:8px 12px;border:0;background:#1976d2;color:#fff;border-radius:4px;cursor:pointer;text-decoration:none}
    .btn.secondary{background:#666}
    .hint{color:#666;font-size:0.9rem;margin-top:8px}
    pre{background:#f8f8f8;padding:8px;border-radius:4px;overflow:auto}
    form.token-form{margin-top:16px;border:1px solid #e0e0e0;padding:12px;border-radius:6px;background:#fafafa}
    form.token-form label{display:block;margin-top:8px;font-size:0.9rem}
    form.token-form input[type="text"], form.token-form input[type="url"]{width:100%;padding:6px;box-sizing:border-box}
    .form-actions{margin-top:10px}
  </style>
</head>
<body>
  <h1>Authorization Callback</h1>
  <p class="hint">このページは認可応答 (クエリパラメータ) を表示します。下のフォームで token エンドポイントへリクエストを送信できます。</p>

  <div id="result">
    <p>読み込み中…</p>
  </div>

  <div class="actions">
    <a class="btn" id="backBtn" href="/authorization_flow">Back to Authorization Flow</a>
    <a class="btn secondary" id="logoutBtn"
       href="http://localhost:8080/realms/myrealm/protocol/openid-connect/logout?client_id=semi_client&post_logout_redirect_uri=http%3A%2F%2Flocalhost%3A8081%2F">
       Logout
    </a>
  </div>

  <!-- Token request form -->
  <form id="tokenForm" class="token-form" onsubmit="return false;">
    <strong>Token request</strong>
    <label>token_endpoint（省略可。サーバのデフォルトが使用されます）
      <input type="url" id="token_endpoint" name="token_endpoint" 
      placeholder="(省略可) http://localhost:8080/realms/myrealm/protocol/openid-connect/auth/token">
    </label>

    <label>code
      <input type="text" id="code" name="code" required>
    </label>

    <label>state
      <input type="text" id="state" name="state">
    </label>

    <label>redirect_uri
      <input type="url" id="redirect_uri" name="redirect_uri" value="http://localhost:8081/callback">
    </label>

    <label>client_id
      <input type="text" id="client_id" name="client_id" value="semi_client">
    </label>

    <label>client_secret
      <input type="text" id="client_secret" name="client_secret" value="Gx6Yh6Q9mVWyPeg9GDIKgKzTiN8WU5Cf">
    </label>

    <!-- PKCE: フロントで code_verifier を保持している場合に備え input を追加 -->
    <label>code_verifier（サーバ側でセッションに保存しているため空のままでもPKCE利用可）
      <input type="text" id="code_verifier" name="code_verifier" placeholder="（例: ランダムな verifier）">
    </label>

    <div class="form-actions">
      <button type="button" class="btn" id="sendBtn">トークン要求送信</button>
      <label style="margin-left:12px;"><input type="checkbox" id="autoSend"> 読み込み時に自動送信</label>
    </div>
  </form>

  <h2>レスポンス</h2>
  <pre id="responseBox">未送信</pre>

  <script>
    function parseQuery(qs) {
      if (!qs) return {};
      const s = qs.startsWith('?') ? qs.substring(1) : qs;
      const params = new URLSearchParams(s);
      const obj = {};
      for (const [k, v] of params.entries()) {
        if (obj[k] === undefined) obj[k] = v;
        else if (Array.isArray(obj[k])) obj[k].push(v);
        else obj[k] = [obj[k], v];
      }
      return obj;
    }

    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // base64url -> base64 変換して atob でデコード（UTF-8 対応）
    function base64UrlDecodeToString(input) {
      try {
        let b64 = input.replace(/-/g, '+').replace(/_/g, '/');
        const pad = b64.length % 4;
        if (pad === 2) b64 += '==';
        else if (pad === 3) b64 += '=';
        else if (pad === 1) b64 += '===';
        const binary = atob(b64);
        // UTF-8 対応デコード
        return decodeURIComponent(Array.prototype.map.call(binary, c =>
          '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)
        ).join(''));
      } catch (e) {
        return null;
      }
    }

    // JWT の payload をデコードしてオブジェクトを返す（失敗時は null）
    function decodeJwtPayload(jwt) {
      if (!jwt) return null;
      const parts = jwt.split('.');
      if (parts.length < 2) return null;
      const payload = parts[1];
      const decoded = base64UrlDecodeToString(payload);
      if (!decoded) return null;
      try {
        return JSON.parse(decoded);
      } catch (e) {
        return null;
      }
    }

    // オブジェクトを整形して文字列にする（key: "value" の順で改行）
    function formatJson(obj) {
      try {
        return JSON.stringify(obj, null, 2);
      } catch (e) {
        return String(obj);
      }
    }

    function render() {
      const query = window.location.search || '';
      const params = parseQuery(query);
      const container = document.getElementById('result');
      container.innerHTML = '';

      const raw = document.createElement('div');
      raw.innerHTML = '<strong>Authorization Response</strong>';
      const pre = document.createElement('pre');
      pre.textContent = query || '(none)';
      raw.appendChild(pre);
      container.appendChild(raw);

      const keys = Object.keys(params);
      if (keys.length === 0) {
        const p = document.createElement('p');
        p.textContent = 'クエリパラメータが見つかりません。';
        container.appendChild(p);
      } else {
        const tbl = document.createElement('table');
        const thead = document.createElement('thead');
        thead.innerHTML = '<tr><th>Parameter</th><th>Value</th></tr>';
        tbl.appendChild(thead);
        const tbody = document.createElement('tbody');

        keys.forEach(k => {
          const v = params[k];
          const tr = document.createElement('tr');
          const tdKey = document.createElement('td');
          tdKey.textContent = k;
          const tdVal = document.createElement('td');
          if (Array.isArray(v)) {
            tdVal.innerHTML = v.map(x => '<div>' + escapeHtml(x) + '</div>').join('');
          } else {
            tdVal.textContent = v;
          }
          tr.appendChild(tdKey);
          tr.appendChild(tdVal);
          tbody.appendChild(tr);
        });

        tbl.appendChild(tbody);
        container.appendChild(tbl);
      }

      // 自動でフォームに値を設定
      const codeInput = document.getElementById('code');
      const stateInput = document.getElementById('state');
      const redirectInput = document.getElementById('redirect_uri');
      const verifierInput = document.getElementById('code_verifier');

      if (params.code) codeInput.value = params.code;
      if (params.state) stateInput.value = params.state;
      if (params.redirect_uri) redirectInput.value = params.redirect_uri;

      // PKCE: フロント側で code_verifier を保存している場合は復元して表示
      // まず URL クエリに code_verifier があれば優先、なければ localStorage/sessionStorage を参照
      if (params.code_verifier) {
        verifierInput.value = params.code_verifier;
      } else {
        try {
          const fromLocal = localStorage.getItem('code_verifier') || sessionStorage.getItem('code_verifier');
          if (fromLocal) verifierInput.value = fromLocal;
        } catch (e) {
          // storage access denied 等は無視
        }
      }
    }

    async function sendTokenRequest() {
      const data = new URLSearchParams();
      const fields = ['token_endpoint','code','redirect_uri','client_id','client_secret','state','code_verifier'];
      fields.forEach(f => {
        const el = document.getElementById(f);
        if (!el) return;
        const v = el.value;
        if (v) data.append(f, v);
      });
      // grant_type はデフォルトで authorization_code（サーバ側でも default）
      data.append('grant_type', 'authorization_code');

      const respBox = document.getElementById('responseBox');
      respBox.textContent = '送信中...';

      try {
        const resp = await fetch('/token_request', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: data.toString()
        });
        const text = await resp.text();
        // まず HTTP ステータスを表示
        let out = 'HTTP ' + resp.status + '\n\n';

        // JSON として解析できれば整形して表示
        let parsed = null;
        try {
          parsed = JSON.parse(text);
        } catch (e) {
          parsed = null;
        }

        if (parsed) {
          out += formatJson(parsed);

          // access_token があれば JWT をデコードして表示
          if (parsed.access_token) {
            const decoded = decodeJwtPayload(parsed.access_token);
            out += '\n\nDecoded access_token payload:\n';
            out += decoded ? formatJson(decoded) : '(unable to decode JWT payload)';
          }
        } else {
          // JSON でなければ生のレスポンスを表示
          out += text;
        }

        respBox.textContent = out;
      } catch (e) {
        respBox.textContent = '送信失敗: ' + e.toString();
      }
    }

    // 初期レンダリングとイベント登録
    (function(){
      render();
      document.getElementById('sendBtn').addEventListener('click', sendTokenRequest);
      // 自動送信がチェックされていればページ読み込み時に送信
      window.addEventListener('load', function(){
        if (document.getElementById('autoSend').checked) {
          const codeVal = document.getElementById('code').value;
          if (codeVal) sendTokenRequest();
        }
      });
    })();
  </script>
</body>
</html>